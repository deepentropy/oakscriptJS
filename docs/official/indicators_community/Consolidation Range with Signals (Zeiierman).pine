// This work is licensed under a Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) https://creativecommons.org/licenses/by-nc-sa/4.0/

// Â© Zeiierman {
//@version=6
indicator('Consolidation Range with Signals (Zeiierman)', overlay=true, max_labels_count = 500, max_lines_count = 500)
//~~}

// ~~ Tooltips {
var string t1 = "Select the method used for detecting ranging market conditions.\n\n
 ADX: Uses the Average Directional Index to identify non-trending periods when ADX is below a set threshold.\n\n
 Volatility: Detects ranges by identifying periods of compression in volatility using standard deviation, variance, and ATR filters.\n\n
 Price Action: Confirms range by measuring the high-low percentage contraction and requiring a minimum number of DMI crosses, suggesting indecision or balance in price action."
var string t2 = "Length or period used for detecting the range."
var string t3 = "Multiplier applied to the calculated band distance."
var string t4 = "Toggle to display Take Profit and Stop Loss levels on the chart."
var string t5 = "Minimum number of bars between two consecutive SL/TP entries."
var string t6 = "Stop Loss multiplier from the filtered base value."
var string t7 = "Take Profit 1 multiplier from the filtered base value."
var string t8 = "Take Profit 2 multiplier from the filtered base value."
var string t9 = "Take Profit 3 multiplier from the filtered base value."
var string t10 = "ADX threshold under which the market is considered ranging."
var string t11 = "Smoothing period used for the ADX calculation."
var string t12 = "Standard deviation compression threshold used to detect low volatility."
var string t13 = "Variance compression threshold used to detect low volatility."
var string t14 = "ATR compression threshold used to detect low volatility."
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Inputs {
// ~~ Range {
method    = input.string("ADX", options=["ADX", "Volatility"], title="Range Detection Method", group="Range Detection", tooltip=t1)
len       = input.int(10, minval=2, title="Range Period", group="Range Detection", tooltip=t2)
band_mult = input.float(1.8, step=0.1, minval=0.01,title="Range Multiplier", group="Range Detection", tooltip=t3)
upper_col = input.color(#0060e6, title="Range", group="Range Detection", inline="bandcol")
lower_col = input.color(#29fafa, title="", group="Range Detection", inline="bandcol")
pos_col = input.color(#0060e6, title="Trend", group="Range Detection", inline="trendcol")
neg_col = input.color(#29fafa, title="", group="Range Detection", inline="trendcol")
//~~}
// ~~ SL/TP {
showTP    = input.bool(true, title="Show SL/TP Levels", group="Targets", tooltip=t4)
cooldown  = input.int(20, title="SL/TP Cooldown (Bars)", group="Targets", tooltip=t5)
sl_mult   = input.float(0.4, step=0.1, minval=0.01,title="SL", group="Targets", inline="sl", tooltip=t6)
showsl    = input.bool(true, title="", group="Targets", inline="sl", tooltip=t6)
tp1_mult  = input.float(0.5, step=0.1, minval=0.01,title="TP1", group="Targets", inline="tp1", tooltip=t7)
showtp1   = input.bool(true, title="", group="Targets", inline="tp1", tooltip=t7)
tp2_mult  = input.float(1.0, step=0.1, minval=0.01,title="TP2", group="Targets", inline="tp2", tooltip=t8)
showtp2   = input.bool(false, title="", group="Targets", inline="tp2", tooltip=t8)
tp3_mult  = input.float(2.0, step=0.1, minval=0.01,title="TP3", group="Targets", inline="tp3", tooltip=t9)
showtp3   = input.bool(false, title="", group="Targets", inline="tp3", tooltip=t9)

entry_col = input.color(color.blue, title="Entry", group="Targets", inline="tpcol")
sl_col    = input.color(#ff0000, title="SL", group="Targets", inline="tpcol")
bullColor = input.color(#09c10f, title="TP", group="Targets", inline="tpcol")
bearColor = input.color(#ff69cb, title="", group="Targets", inline="tpcol")
//~~}
// ~~ ADX {
adx_thresh = input.int(17, step=1, minval=0,title="ADX Threshold", group="ADX", tooltip=t10)
adx_smooth = input.int(10, step=1, minval=0,title="ADX Smoothing", group="ADX", tooltip=t11)
//~~}
// ~~ Volatility {
vol_mult_std = input.float(0.8, step=0.1, minval=0.001, title="StdDev Multiplier", group="Volatility", tooltip=t12)
vol_mult_var = input.float(0.8, step=0.1, minval=0.001,title="Variance Multiplier", group="Volatility", tooltip=t13)
vol_mult_atr = input.float(0.9, step=0.1, minval=0.001,title="ATR Multiplier", group="Volatility", tooltip=t14)
//~~}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ ADX {
[_, _, adx] = ta.dmi(len, adx_smooth)
isADX       = adx < adx_thresh
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Volatility Compression {
logret  = math.log(close / close[1])
std_now = ta.stdev(logret, len)
std_avg = ta.sma(std_now, len)
atr_now = ta.atr(len)
atr_avg = ta.sma(atr_now, len)
var_now = ta.variance(logret, len)
var_avg = ta.sma(var_now, len)
isVolatility = std_now < std_avg * vol_mult_std and var_now < var_avg * vol_mult_var and atr_now < atr_avg * vol_mult_atr
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Switch {
methodDetected = (method == "ADX" and isADX) or
                 (method == "Volatility" and isVolatility)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Var {
var float rngfilt       = close
var color trendColor    = na
var bool rangeVisible   = false
var float prev_hi       = na
var float prev_lo       = na
var int rangeStartBar   = na
var int rangeBarsActive = 0
var int lastBreakoutBar = na

if methodDetected and na(rangeStartBar)
    rangeStartBar := bar_index
else if not methodDetected
    rangeStartBar := na

if methodDetected
    rangeVisible := true
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Range Calculation {
diff = math.abs(high - low[1])
r    = ta.sma(2.618 * diff, 2000) * band_mult
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Range Calculation Functions {
pricejump(prev) =>
    highJump = prev + math.abs(close - prev) / r * r
    lowJump  = prev - math.abs(close - prev) / r * r
    [highJump, lowJump]

rangefilter(hhjump, lljump, prev) =>
    hhBreak    = close > prev
    hhTooClose = close - r < prev
    hhShift    = close - r
    llTooClose = close + r > prev
    llShift    = close + r
    step1      = hhBreak ? (hhTooClose ? prev : hhShift) : (llTooClose ? prev : llShift)
    hhAbove = close >= prev + r
    llBelow = close <= prev - r
    hhAbove ? hhjump : llBelow ? lljump : step1

bands(filt) => [filt + r, filt - r]
trenddir(filt) => [filt > nz(filt[1]), filt < nz(filt[1])]
trendcomp(filt) => [filt, ta.sma(filt, 2), ta.sma(filt, 4)]

prev = nz(rngfilt[1])
[hhJ, llJ] = pricejump(prev)
rngfilt    := rangefilter(hhJ, llJ, prev)
prev_rngfilt      = nz(rngfilt[1])
rngfilt_step_up   = rngfilt > prev_rngfilt
rngfilt_step_down = rngfilt < prev_rngfilt

[hiband, loband] = bands(rngfilt)
[up, down]       = trenddir(rngfilt)
[TrendFast, TrendMed, TrendLong] = trendcomp(rngfilt)

if methodDetected
    prev_hi := hiband
    prev_lo := loband

if not methodDetected and (close[1] > prev_hi or close[1] < prev_lo)
    rangeVisible := false

MIDX1 = (hiband - rngfilt) / 3
MID1  = rngfilt + MIDX1
MID2  = MID1 + MIDX1
MIDX2 = (rngfilt - loband) / 3
MID3  = rngfilt - MIDX2
MID4  = MID3 - MIDX2
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ Plot {
trendColor := up ? pos_col : down ? neg_col : trendColor[1]
plotTrend = plot(rangeVisible ? TrendFast : close, "Trend", rangeVisible ? trendColor:color.new(trendColor,100), 1)

plotMid1 = plot(rangeVisible ? MID1 : close, "MID1", rangeVisible ?color.new(upper_col, 50):color.new(upper_col, 100), style= plot.style_stepline)   
plotMid2 = plot(rangeVisible ? MID2 : close, "MID2", rangeVisible ?color.new(upper_col, 50):color.new(upper_col, 100), style= plot.style_stepline)   
plotMid3 = plot(rangeVisible ? MID3 : close, "MID3", rangeVisible ?color.new(lower_col, 50):color.new(lower_col, 100), style= plot.style_stepline)   
plotMid4 = plot(rangeVisible ? MID4 : close, "MID4", rangeVisible ?color.new(lower_col, 50):color.new(lower_col, 100), style= plot.style_stepline)   

fill(plotMid2, plotTrend, MID2, TrendFast, color.new(upper_col, 60),na)
fill(plotMid4, plotTrend, MID4, TrendFast, color.new(lower_col, 60),na)
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}

// ~~ TP and SL {
rangeBarsActive    := na(rangeStartBar) ? 0 : bar_index - rangeStartBar
canTriggerBreakout =  (na(lastBreakoutBar) or bar_index - lastBreakoutBar >= cooldown)
enterLong  = rangeVisible and rngfilt_step_up and canTriggerBreakout
enterShort = rangeVisible and rngfilt_step_down and canTriggerBreakout

calcSLTP(isLong) =>
    base = rngfilt
    offset = r * sl_mult
    tp1off = r * tp1_mult
    tp2off = r * tp2_mult
    tp3off = r * tp3_mult

    stop_ = isLong ? base - offset : base + offset
    tp1_ = isLong ? base + tp1off : base - tp1off
    tp2_ = isLong ? base + tp2off : base - tp2off
    tp3_ = isLong ? base + tp3off : base - tp3off
    [stop_, tp1_, tp2_, tp3_]

drawLevels(entry, sl, tp1, tp2, tp3, col) =>
    if showTP
        line.new(bar_index, entry, bar_index + 20, entry, color=entry_col, width=2)
        if showsl
            line.new(bar_index, sl, bar_index + 20, sl, color=color.new(sl_col, 0), width=2)
        if showtp1
            line.new(bar_index, tp1, bar_index + 20, tp1, color=color.new(col, 0), width=2)
        if showtp2
            line.new(bar_index, tp2, bar_index + 20, tp2, color=color.new(col, 0), width=2)
        if showtp3
            line.new(bar_index, tp3, bar_index + 20, tp3, color=color.new(col, 0), width=2)
    if showTP
        label.new(bar_index+ 20, entry, "Entry", style=label.style_label_left, color=entry_col, textcolor=color.white, size = size.tiny)
        if showsl
            label.new(bar_index+ 20, sl,    "SL", style=label.style_label_left, color=color.new(sl_col, 0), textcolor=color.white, size = size.tiny)
        if showtp1
            label.new(bar_index+ 20, tp1,   "TP 1", style=label.style_label_left, color=color.new(col, 0), textcolor=color.white, size = size.tiny)
        if showtp2    
            label.new(bar_index+ 20, tp2,   "TP 2", style=label.style_label_left, color=color.new(col, 0), textcolor=color.white, size = size.tiny)
        if showtp3
            label.new(bar_index+ 20, tp3,   "TP 3", style=label.style_label_left, color=color.new(col, 0), textcolor=color.white, size = size.tiny)

var float SL  = na
var float TP1 = na
var float TP2 = na
var float TP3 = na

if enterLong and showTP and (na(lastBreakoutBar) or bar_index - lastBreakoutBar >= cooldown)
    [s, t1_, t2_, t3_] = calcSLTP(true)
    SL := s, TP1 := t1_, TP2 := t2_, TP3 := t3_
    drawLevels(close, SL, TP1, TP2, TP3, bullColor)
    lastBreakoutBar := bar_index

if enterShort and showTP and (na(lastBreakoutBar) or bar_index - lastBreakoutBar >= cooldown)
    [s, t1_, t2_, t3_] = calcSLTP(false)
    SL := s, TP1 := t1_, TP2 := t2_, TP3 := t3_
    drawLevels(close, SL, TP1, TP2, TP3, bearColor)
    lastBreakoutBar := bar_index
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}    